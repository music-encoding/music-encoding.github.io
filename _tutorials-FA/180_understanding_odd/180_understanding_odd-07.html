<div>


    <p>
        همان‌طور که در مرحله قبل دیدیم، بخش زیادی از سلسله‌مراتب MEI از طریق استفاده از کلاس‌های مدل برقرار می‌شود.
        مکانیسمی بسیار مشابه توسط ODD برای دسترس‌پذیر کردن خصیصه‌ها در المنت‌های متعدد استفاده می‌شود. اما قبل از بررسی
        کلاس‌های خصیصه، بیایید نگاهی کوتاه به نحوه تعریف واقعی یک خصیصه در ODD بیندازیم. خصیصه <em>@xml:id</em> در هر
        المنت MEI موجود است و با مشخصات زیر تعریف شده است:
    </p>
    <pre class="codeblock">&lt;attDef ident="xml:id" usage="opt"&gt;
            &lt;desc&gt;Regularizes the naming of an element and thus facilitates building links between it and other resources. Each id attribute within a document must have a unique value.&lt;/desc&gt;
            &lt;datatype maxOccurs="1" minOccurs="1"&gt;
                &lt;rng:data type="ID"/&gt;
            &lt;/datatype&gt;
        &lt;/attDef&gt;</pre>
    <p>
        خصیصه‌ها با استفاده از المنت <a href="https://tei-c.org/release/doc/tei-p5-doc/en/html/ref-attDef.html"
            target="_blank" rel="noopener, noreferrer">&lt;attDef&gt;</a>
        مشخص می‌شوند و از برخی از قواعدی که قبلاً روی المنت‌ها و کلاس‌های مدل دیده‌ایم، پیروی می‌کنند: نام آنها در خصیصه
        <em>@ident</em> ارائه می‌شود و دارای یک المنت <em>&lt;desc&gt;</em> با توضیح مختصر هستند. آنچه جدید است، خصیصه
        <strong>@usage</strong> است که مورد استفاده از خصیصه را مشخص می‌کند. مقدار در اینجا، "<em>opt</em>"، برای
        خصیصه‌های اختیاری استفاده می‌شود – <em>@xml:id</em> می‌تواند روی همه المنت‌های MEI استفاده شود، اما الزامی به
        استفاده آن نیست. مقادیر دیگر مجاز برای <em>@usage</em> شامل "<em>req</em>" (الزامی) و "<em>rec</em>" (توصیه‌شده
        در صورت لزوم) هستند.
    </p>
    <p>
        حالا بیایید ببینیم این المنت‌های <em>&lt;attDef&gt;</em> کجا قرار دارند. حتی اگر این واقعاً راه‌حل ترجیحی نباشد،
        گاهی اوقات خصیصه‌ها در همان المنتی که باید استفاده شوند تعریف می‌شوند، مانند خصیصه <em>@type</em> در <a
            href="https://music-encoding.org/guidelines/v4/elements/meihead.html" target="_blank"
            rel="noopener, noreferrer">&lt;meiHead&gt;</a>:
    </p>
    <pre class="codeblock">&lt;elementSpec ident="meiHead" module="MEI.header"&gt;
            &lt;desc&gt;(MEI header) – Supplies the descriptive and declarative metadata prefixed to every
                MEI-conformant text.&lt;/desc&gt;
            &lt;classes&gt;
                &lt;!-- memberOf elements skipped for brevity --&gt;
            &lt;/classes&gt;
            &lt;content&gt;
                &lt;!-- contents skipped for brevity --&gt;
            &lt;/content&gt;
            &lt;!-- constraintSpecs skipped for brevity --&gt;
            &lt;attList&gt;
                &lt;attDef ident="type" usage="opt"&gt;
                    &lt;desc&gt;Specifies the kind of document to which the header is attached, for example whether it
                        is a corpus or individual text.&lt;/desc&gt;
                    &lt;valList type="closed"&gt;
                        &lt;valItem ident="music"&gt;
                            &lt;desc&gt;Header is attached to a music document.&lt;/desc&gt;
                        &lt;/valItem&gt;
                        &lt;valItem ident="corpus"&gt;
                            &lt;desc&gt;Header is attached to a corpus.&lt;/desc&gt;
                        &lt;/valItem&gt;
                        &lt;valItem ident="independent"&gt;
                            &lt;desc&gt;Header is independent; i.e., not attached to either a music or a corpus
                                document.&lt;/desc&gt;
                        &lt;/valItem&gt;
                    &lt;/valList&gt;
                &lt;/attDef&gt;
            &lt;/attList&gt;
            &lt;!-- remarks skipped for brevity --&gt;
        &lt;/elementSpec&gt;</pre>
    <p>
        همان‌طور که می‌بینیم، خصیصه‌ها تنها در یک المنت <em>&lt;attList&gt;</em> درون <em>&lt;elementSpec&gt;</em> قرار
        دارند. با این حال، در بیشتر موارد، خصیصه‌ای در نظر گرفته شده است که در بیش از یک المنت موجود باشد. خصیصه
        <em>@xml:id</em> که در بالا معرفی شد در هر المنت MEI موجود است، بنابراین باید چند صد بار تعریف شود – دوباره، این
        نه نگهداری‌پذیر است و نه کارآمد. در عوض، ODD بار دیگر از یک سیستم کلاس استفاده می‌کند، این بار برای
        <strong>کلاس‌های خصیصه</strong>. بیایید ببینیم چگونه <em>@xml:id</em> واقعاً در MEI از طریق کلاس خصیصه
        <em>att.id</em> توزیع می‌شود:
    </p>
    <pre class="codeblock">&lt;classSpec ident="att.id" module="MEI.shared" type="atts"&gt;
            &lt;desc&gt;Attributes that uniquely identify an element.&lt;/desc&gt;
            &lt;attList org="group"&gt;
                &lt;attDef ident="xml:id" usage="opt"&gt;
                    &lt;!-- skipping this, as it is the very same as in the example above --&gt;
                &lt;/attDef&gt;
            &lt;/attList&gt;
        &lt;/classSpec&gt;</pre>
    <p>
        قبلاً المنت <em>&lt;attDef&gt;</em> را دیده‌ایم و تفاوتی بین خصیصه‌هایی که درون یک المنت یا درون یک کلاس خصیصه
        تعریف شده‌اند وجود ندارد. اما همچنین قبلاً المنت <a
            href="https://tei-c.org/release/doc/tei-p5-doc/en/html/ref-classSpec.html" target="_blank"
            rel="noopener, noreferrer">&lt;classSpec&gt;</a> را در کلاس‌های مدل دیده‌ایم. تنها تفاوت این است که کلاس‌های
        خصیصه از خصیصه <strong>@type="atts"</strong> استفاده می‌کنند، و در حالی که نام کلاس‌های مدل با "<em>model.</em>"
        شروع می‌شود، نام کلاس‌های خصیصه در MEI همیشه با "<em>att.</em>" شروع می‌شود.
    </p>
    <p>
        در اوایل این آموزش، تعریف المنت <a href="https://music-encoding.org/guidelines/v4/elements/role.html"
            target="_blank" rel="noopener, noreferrer">&lt;role&gt;</a> را دیدیم. بیایید دوباره به آن نگاهی بیندازیم و
        برخی قسمت‌های آن را نادیده بگیریم:
    </p>
    <pre class="codeblock">&lt;elementSpec ident="role" module="MEI.shared"&gt;
            &lt;desc&gt;Name of a dramatic role, as given in a cast list.&lt;/desc&gt;
            &lt;classes&gt;
                &lt;memberOf key="att.common"/&gt;
                &lt;memberOf key="att.facsimile"/&gt;
                &lt;memberOf key="att.lang"/&gt;
            &lt;/classes&gt;
            &lt;!-- skipping content and remarks here --&gt;
        &lt;/elementSpec&gt;</pre>
    <p>
        بر این اساس، <em>&lt;role&gt;</em> عضو کلاس‌های خصیصه <em>att.common</em>، <em>att.facsimile</em> و
        <em>att.lang</em> است، اما نه <em>att.id</em>. با این حال، مستندات <em>&lt;role&gt;</em> بیان می‌کند که
        <em>@xml:id</em> در دسترس است. پاسخ این است که اینجا هم از <em>کلاس‌های تو در تو</em> استفاده شده.
        <em>&lt;role&gt;</em> به کلاس خصیصه <em>att.common</em> عضو می‌شود و همه خصیصه‌های آن کلاس را به دست می‌آورد (که
        در واقع هیچ کدام نیستند). در عوض، <em>att.common</em> خود به کلاس خصیصه <em>att.basic</em> عضو می‌شود (که خصیصه
        <em>@xml:base</em> را وارد می‌کند)، و آن به کلاس خصیصه <em>att.id</em> عضو می‌شود که در نهایت خصیصه
        <em>@xml:id</em> را وارد می‌کند. برای دیدن این مکانیزم در عمل، بیایید نگاهی کوتاه به <em>att.common</em>
        بیندازیم:
    </p>



    <pre class="codeblock">&lt;classSpec ident="att.common" module="MEI.shared" type="atts"&gt;
            &lt;desc&gt;Attributes common to many elements.&lt;/desc&gt;
            &lt;classes&gt;
                &lt;memberOf key="att.basic"/&gt;
                &lt;memberOf key="att.labelled"/&gt;
                &lt;memberOf key="att.linking"/&gt;
                &lt;memberOf key="att.nNumberLike"/&gt;
                &lt;memberOf key="att.responsibility"/&gt;
                &lt;memberOf key="att.typed"/&gt;
            &lt;/classes&gt;
        &lt;/classSpec&gt;</pre>
    <p>
        باز هم، از طریق استفاده از یک المنت <em>&lt;memberOf&gt;</em> با <em>@key</em> مناسب، عضویت در کلاس‌های
        مختلف در
        MEI محقق می‌شود، بنابراین این مکانیزم باید برای شما آشنا باشد. و مانند <em>کلاس‌های مدل</em>، <em>کلاس‌های
            خصیصه</em> نیز از کلاس‌های نسبتاً عمومی تا مجموعه‌های خاص‌تر از خصیصه‌های هم‌راستا استفاده می‌کنند. با
        عضو
        شدن در کلاس(های) خصیصه مناسب، یک المنت می‌تواند دقیقاً مجموعه مناسب از خصیصه‌ها را به دست آورد و این امکان
        وجود
        دارد که به صورت انتخابی خصیصه‌ها را به المنت‌های جدید یا موجود اضافه یا از آنها حذف کنیم.
    </p>
    <p>
        مشخصات <em>att.common</em> که در بالا مشاهده می‌شود، کلاس خصیصه دیگری به نام <em>att.typed</em> را فاش
        می‌کند که
        یک
        خصیصه <em>@type</em> را فراهم می‌کند. واضح است که این خصیصه در <em>&lt;meiHead&gt;</em> استفاده نشده است،
        همانطور که
        در بالا دیده می‌شود. دلیل این امر این است که کلاس خصیصه یک خصیصه <em>@type</em> را فراهم می‌کند که تنها یک
        توضیح بسیار عمومی دارد: <em>تعیین‌کننده‌ای که عنصر را از نظر خاصی توصیف می‌کند و از هر طرح یا طبقه‌بندی
            مناسب
            که برچسب‌های تک‌کلمه‌ای را به کار می‌برد، استفاده می‌کند.</em> در مقایسه با آن، <em>@type</em> در
        <em>&lt;meiHead&gt;</em>
        تعریف بسیار دقیقی داشت. به طور کلی، MEI سعی می‌کند از استفاده از همان نام خصیصه با تعاریف چندگانه اجتناب
        کند،
        اما این همیشه ممکن نیست و حداقل
        باعث سردرگمی <em>فنی</em> نمی‌شود. با دیدگاه "بر اساس کلاس" در مورد خصیصه‌ها (به <a
            href="https://music-encoding.org/guidelines/v4/elements/meihead.html#attributes" target="_blank"
            rel="noopener, noreferrer">&lt;meiHead&gt;</a> مشخصات)، می‌توان به راحتی پیگیری کرد که هر خصیصه مجاز از
        کجا
        آمده است.
    </p>
    <p>
        تنها بخش بزرگی که برای درک ODD&nbsp;<span style="font-size: 2rem;">&nbsp;</span><span
            style="font-size: 2rem;">باقی‌مانده،&nbsp;</span><span style="font-size: 2rem;">نوع داده‌ها است که در مرحله
            بعدی این آموزش معرفی خواهد شد.</span></p>
</div>
